const fs = require("fs");
const path = require("path");
const ini = require("ini");

const Migrations = artifacts.require("Migrations");
const GameToken = artifacts.require("GameToken");

/**
 * @dev Migration script for Decentralized Interledger
 * For networks starting with left, right:
 *  - deploy the token contract
 *  - generate configuration files (config_file-node-1.cfg, config_file-node-2.cfg, etc.):
 *    - first available account will be used as minter for the first node, second account
 *      for the second node, etc.
 * For network development and others: deploy the token contract
 * @param --nodes       number of nodes in the DSM ledgers (default: 1)
 * @param --config_file path to base config file to be used for deployment
 *                      (default: ../../configs/dib.cfg)
 */

// parse custom arguments
const argv = require('minimist')(process.argv.slice(2));

module.exports = function(deployer, network, accounts) {
  deployer.then(async () => {
    alice = accounts[0];

    // check if network name starts with left or right
    if ((network.substr(0, 4) == 'left') || (network.substr(0, 5) == 'right')) {
      // get path to the configuration file
      let config_file_path, config, ledger, nodes;
      if (typeof(argv['config_file']) != 'undefined') {
          config_file_path = argv['config_file'];
      } else {
          config_file_path = '../../configs/dib.cfg';
      }

      // check --nodes argument
      if (Number.isFinite(argv['nodes'])) {
        if (argv['nodes'] <= accounts.length) {
          nodes = argv['nodes'];
        } else {
          nodes = accounts.length;
          console.log("Warning: not enought available accounts for all nodes, limiting number of nodes to",
                      nodes);
        }
      } else {
        console.log("Warning: Nodes parameter missing or invalid, defaulting to 1");
        nodes = 1;
      }

      // check --sc argument
      if (Number.isFinite(argv['deployments'])) {
        numberOfDeployments = argv['deployments'];
      } else {
        console.log("Warning: Deployments parameter missing or invalid, defaulting to 1");
        numberOfDeployments = 1;
      }

      const base_path = "ledgers/solidity/contracts/";

      await deployer.deploy(Migrations);

      for (let j=1; j <= numberOfDeployments; j++) {
        // constructor of GameToken contains *other* minters, which should not include alice, since
        // otherwise deployment will get stuck
        const token = await deployer.deploy(GameToken, "GameToken", "GAME", accounts.slice(1, nodes),
                                            {'from': alice});

        // create Interledger configuration files for all nodes: config_file_path-node-#.ext
        let new_config_file, extension;
        for (i = 1; i <= nodes; i++) {
          if (path.extname(config_file_path)) { // check for config file extension
            extension = path.extname(config_file_path);
            new_config_file = path.dirname(config_file_path) + "/" +
                                  path.basename(config_file_path, extension) + "-node-" + j.toString() + "-" + i.toString() + extension;
          } else { // no file extension
            new_config_file = path.dirname(config_file_path) + "/" +
                                  path.basename(config_file_path) + "-node-" + j.toString() + "-" + i.toString();
          }

          // check wherever the config file already exists (generated by the migration run previously)
          if (fs.existsSync(new_config_file)) {
              // modify existing file
              config = ini.parse(fs.readFileSync(new_config_file, 'utf-8'));
          } else {
              // generate new file based on base config file
              config = ini.parse(fs.readFileSync(config_file_path, 'utf-8'));
          }

          // read correct ledger entry from the config file
          if (network.substr(0, 4) == 'left') {
            ledger = config['service']['left'];
          } else { // right
            ledger = config['service']['right'];
          }

          // update minter and token.address
          config[ledger].minter = accounts[i-1];
          config[ledger].contract = token.address;
          config[ledger].contract_abi = base_path + "GameToken.abi.json";

          config.node.node_id = i;

          fs.writeFileSync(new_config_file, ini.stringify(config));
        }
      }
      return;
    }

    // Local truffle test network if development is not present in config
    await deployer.deploy(Migrations);
    token = await deployer.deploy(GameToken, "GameToken", "GAME", [], {'from': alice});

  });
};
